---
title: "Ames Home Renovation Premium Prediction"
author: Xineng Na
date: "2025-06-14"
output:
  pdf_document: default
  html_document: default
editor_options:
  markdown:
    wrap: 72
---

# 1. Setup and Load Necessary R Packages
```{r load_packages, message=FALSE, warning=FALSE}
# Ensure necessary packages are installed
# install.packages("AmesHousing")
# install.packages("dplyr")
# install.packages("ggplot2")
# install.packages("gtsummary")
# install.packages("tidyr")
# install.packages("patchwork")
# install.packages("broom")


library(AmesHousing)
library(MASS)
library(dplyr)
library(ggplot2)
library(gtsummary)
library(tidyr)
library(patchwork)
library(broom)
```

# 2. Data Loading and Selection
```{r load_data}
# Data source: Ames Housing dataset from the AmesHousing R package 
# (originally collected by De Cock, U. (2011). Available in the package documentation.)
ames_data <- make_ames()

# Here we choose Sale_Price as the response variable and the rest are predictor variables
selected_vars_data <- ames_data %>% 
  select(Sale_Price, Year_Built, Year_Remod_Add, Kitchen_Qual, Gr_Liv_Area, Overall_Qual, Year_Sold)
```

# 3. Handling Missing Values
```{r handle_missing}
clean_ames_data <- selected_vars_data %>%
  drop_na(Sale_Price, Year_Built, Year_Remod_Add, Kitchen_Qual, Gr_Liv_Area, Overall_Qual, Year_Sold)
```

# 4. Checking Data Integrity
```{r check_data}
print(paste("Original data dimensions (from make_ames()):", paste(dim(ames_data), collapse = " x ")))
print(paste("Dimensions of cleaned data for analysis:", paste(dim(clean_ames_data), collapse = " x ")))
```

# 5. Exporting Cleaned Data
```{r export_data}
write.csv(clean_ames_data, file = "clean_ames_data_for_analysis.csv", row.names = FALSE)
```

# 6. Deriving Variables
```{r derive_variables}
clean_ames_data <- clean_ames_data %>% 
  # Create a new column 'Renovation_Status' based on whether the house was remodeled
  mutate(
    Renovation_Status = ifelse(Year_Remod_Add > Year_Built, "Remodeled", "Not_Remodeled")
  ) %>%
  # Convert 'Renovation_Status' to a factor with a specified order
  mutate(Renovation_Status = factor(Renovation_Status, levels = c("Not_Remodeled", "Remodeled")))

# Create a new column 'House_Age'
clean_ames_data <- clean_ames_data %>%
  mutate(House_Age = Year_Sold - Year_Built,
         House_Age_Adj = ifelse(House_Age <= 0, 1, House_Age)
  )

# Kitchen_Qual order: Poor < Fair < Typical < Good < Excellent
clean_ames_data$Kitchen_Qual <- factor(
  clean_ames_data$Kitchen_Qual,
  levels = c("Poor", "Fair", "Typical", "Good", "Excellent"),
  ordered = TRUE
)

# Corrected Overall_Cond factor conversion
clean_ames_data$Overall_Qual <- factor(clean_ames_data$Overall_Qual,
                                       levels = c("Very_Poor", "Poor", "Fair", "Below_Average", "Average",
                                                  "Above_Average", "Good", "Very_Good", "Excellent", "Very_Excellent"),
                                       ordered = TRUE)


lm0 <- lm(Sale_Price ~ Renovation_Status + House_Age +
               Kitchen_Qual + Overall_Qual + Gr_Liv_Area,
           data = clean_ames_data)

bc <- boxcox(lm0, plotit = FALSE)
lambda <- bc$x[which.max(bc$y)]

clean_ames_data <- clean_ames_data %>%
  mutate(
    SalePrice_bc = (Sale_Price^lambda - 1) / lambda
  )

```

# 7. Summary Table for Proposal
```{r summary_table}
# Create summary of response variable
summary_response <- summary(clean_ames_data$Sale_Price)
# Display summary in a clean format for Figure 1
sale_price_summary <- data.frame(
  Statistic = c("Min.", "1st Qu.", "Median", "Mean", "3rd Qu.", "Max."),
  Value = round(as.numeric(summary_response), 0)
)
# Print as a formatted table
knitr::kable(sale_price_summary, caption = "Figure 1: Response Variable Summary")


# Create summary of numerical predictors
summary_numeric <- summary(clean_ames_data[, c("Year_Built", "Gr_Liv_Area")])
# Display summary in a clean format for Figure 2
numeric_summary <- data.frame(
  Statistic = c("Min.", "1st Qu.", "Median", "Mean", "3rd Qu.", "Max."),
  House_Age = c(
    min(clean_ames_data$House_Age_Adj, na.rm = TRUE),
    quantile(clean_ames_data$House_Age_Adj, 0.25, na.rm = TRUE),
    median(clean_ames_data$House_Age_Adj, na.rm = TRUE),
    mean(clean_ames_data$House_Age_Adj, na.rm = TRUE),
    quantile(clean_ames_data$House_Age_Adj, 0.75, na.rm = TRUE),
    max(clean_ames_data$House_Age_Adj, na.rm = TRUE)
  ),
  Gr_Liv_Area = c(
    min(clean_ames_data$Gr_Liv_Area, na.rm = TRUE),
    quantile(clean_ames_data$Gr_Liv_Area, 0.25, na.rm = TRUE),
    median(clean_ames_data$Gr_Liv_Area, na.rm = TRUE),
    mean(clean_ames_data$Gr_Liv_Area, na.rm = TRUE),
    quantile(clean_ames_data$Gr_Liv_Area, 0.75, na.rm = TRUE),
    max(clean_ames_data$Gr_Liv_Area, na.rm = TRUE)
  )
)
# Round the numeric values
numeric_summary$House_Age <- round(numeric_summary$House_Age, 0)
numeric_summary$Gr_Liv_Area <- round(numeric_summary$Gr_Liv_Area, 0)
# Print as a formatted table
knitr::kable(numeric_summary, caption = "Numerical Predictors' Summaries")

# Create summary table for categorical variables
tbl_data <- clean_ames_data[, c("Overall_Qual", "Kitchen_Qual", "Renovation_Status")]
tbl_data$Overall_Qual <- as.factor(tbl_data$Overall_Qual)
cat_summary <- tbl_summary(tbl_data)
# Display summary table
cat_summary %>% 
  as_kable(caption = "Categorical Variables' Summaries")
```

# 8. Model Fitting

$$
SalePrice_{bc} = \beta_0 + \beta_1\,\mathrm{Renovation\_Status}
  + \beta_2\,\mathrm{poly}(House\_Age,2)_1
  + \beta_3\,\mathrm{poly}(House\_Age,2)_2
  + \beta_4\,Kitchen\_Qual \\
  + \beta_5\,Overall\_Qual 
  + \beta_6\,Gr\_Liv\_Area
  + \varepsilon
$$
where $SalePrice_{bc} = \frac{Sale\_Price^{0.2}-1}{0.2}.$

```{r model_fitting}
# clean_ames_data <- clean_ames_data %>%
# drop_na()
min_house_age <- min(clean_ames_data$House_Age, na.rm = TRUE)
print(paste("House_Age min value:", min_house_age))
# Include only factor predictors with at least two levels
factor_preds <- c("Renovation_Status", "Kitchen_Qual", "Overall_Qual")
valid_factors <- factor_preds[sapply(clean_ames_data[factor_preds], function(x) nlevels(x) > 1)]

# Raw Polynomial
mlr_model_renovation <- lm(
  SalePrice_bc ~ Renovation_Status + House_Age_Adj +
                  Kitchen_Qual + Overall_Qual + Gr_Liv_Area,
  data = clean_ames_data
)
# Orthogonal Polynomial
lm_polyAge <- lm(
  SalePrice_bc ~ Renovation_Status +
                poly(House_Age_Adj, 2) +
                Kitchen_Qual + Overall_Qual + Gr_Liv_Area,
  data = clean_ames_data
)
final_model <- lm_polyAge
# Sqrt
clean_ames_data <- clean_ames_data %>%
  mutate(House_Age_sqrt = sqrt(House_Age))
lm_sqrtAge <- lm(
  SalePrice_bc ~ Renovation_Status + House_Age_sqrt +
                Kitchen_Qual + Overall_Qual + Gr_Liv_Area,
  data = clean_ames_data
)
# Log
clean_ames_data <- clean_ames_data %>%
  mutate(
    House_Age_for_log = ifelse(House_Age <= 0, 1, House_Age),
    House_Age_log = log(House_Age_for_log)
  )
lm_logAge <- lm(
  SalePrice_bc ~ Renovation_Status + House_Age_log +
                Kitchen_Qual + Overall_Qual + Gr_Liv_Area,
  data = clean_ames_data
)

models <- list(
  Orig       = mlr_model_renovation,
  PolyAge    = lm_polyAge,
  SqrtAge    = lm_sqrtAge,
  LogAge     = lm_logAge
)
comp <- sapply(models, function(m) c(AIC=AIC(m), BIC=BIC(m),
                                     AdjR2=summary(m)$adj.r.squared))
knitr::kable(round(t(comp),3), caption="Predictor-transform Comparison")

#
mlr_orig <- lm(
  Sale_Price ~ Renovation_Status + House_Age + I(House_Age^2) +
               Kitchen_Qual + Overall_Qual + Gr_Liv_Area,
  data = clean_ames_data
)
#
mlr_log <- lm(
  log(Sale_Price) ~ Renovation_Status + House_Age + I(House_Age^2) +
                    Kitchen_Qual + Overall_Qual + Gr_Liv_Area,
  data = clean_ames_data
)

comp_saleprice <- tibble::tibble(
  Model    = c("Orig", "Log", "BoxCox"),
  AIC      = c(AIC(mlr_orig), AIC(mlr_log), AIC(mlr_model_renovation)),
  BIC      = c(BIC(mlr_orig), BIC(mlr_log), BIC(mlr_model_renovation)),
  AdjR2    = c(summary(mlr_orig)$adj.r.squared,
               summary(mlr_log)$adj.r.squared,
               summary(mlr_model_renovation)$adj.r.squared)
)

knitr::kable(
  comp_saleprice,
  digits = c(0,2,2,3),
  caption = "Sale Price Transformation Comparison"
)
```

# 9. Model Metrics
```{r model_metrics}
r_squared <- summary(final_model)$r.squared
adj_r_squared <- summary(final_model)$adj.r.squared

message("Model R-squared: ", round(r_squared, 4))
message("Model Adjusted R-squared: ", round(adj_r_squared, 4))
```

# 10. Preparing Residuals and Fitted Values
```{r prepare_plots}
fitted_values <- fitted(final_model)
residuals <- residuals(final_model)

plot_data <- clean_ames_data %>%
  mutate(Fitted = fitted_values, Residuals = residuals)
```

# 11. Diagnostic Plots
```{r diagnostic_plots, fig.height=4, fig.width=8, echo = FALSE, results = 'hide'}
p1 <- ggplot(plot_data, aes(x = Fitted, y = Residuals)) +
  geom_point(alpha = 0.6) +
  labs(title = "Residuals vs. Fitted Values(Transformed)", x = "Fitted Values", y = "Residuals") +
  theme_minimal()

p2 <- ggplot(plot_data, aes(sample = Residuals)) +
  stat_qq() +
  stat_qq_line(color = "red") +
  labs(title = "Normal Q-Q Plot(Transformed)", x = "Theoretical Quantiles", y = "Sample Quantiles") +
  theme_minimal()

p3 <- ggplot(plot_data, aes(x = Gr_Liv_Area, y = Residuals)) +
  geom_point(alpha = 0.6) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(title = "Residuals vs. Above Ground Living Area(Transformed)", x = "Above Ground Living Area", y = "Residuals") +
  theme_minimal()

p4 <- ggplot(plot_data, aes(x = House_Age, y = Residuals)) +
  geom_point(alpha = 0.6) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(title = "Residuals vs. House Age(Transformed)", x = "House Age", y = "Residuals") +
  theme_minimal()

# Residual vs Kitchen Quality
p5 <- boxplot(residuals ~ clean_ames_data$Kitchen_Qual, 
        main = "Residual vs Kitchen Quality(Transformed)",
        ylab = "Residuals", xlab = "Kitchen Quality", col = "lightblue")

# Residual vs Renovation Status
p6 <- boxplot(residuals ~ clean_ames_data$Renovation_Status, 
        main = "Residual vs Renovation Status(Transformed)",
        ylab = "Residuals", xlab = "Renovation_Status", col = "lightblue")

# Residual vs Overall Quality
p7 <- boxplot(residuals ~ clean_ames_data$Overall_Qual, 
     main = "Residual vs Overall Quality(Transformed)",
     ylab = "Residuals", xlab = "Overall Quality", col = "lightblue")


p1
p2
p3
p4
p5
p6
p7
```

# 12. Additional Checks
```{r additional-checks, fig.height=4, fig.width=8, echo = FALSE}
# Conditional Mean Response
p8 <- plot(x = fitted_values, y = clean_ames_data$Sale_Price,
     main = "Response vs Fitted(Transformed)",
     xlab = "Fitted", ylab = "Sale Price")
abline(a = 0, b = 1, lty = 2, col = "red")


```

# 13. Final tables
```{r final_tables, echo=FALSE}
library(knitr)
library(tibble)
library(car)
# Section 3: Initial (Untransformed) Model Diagnostics
lm_initial <- lm(
  Sale_Price ~ Renovation_Status + House_Age + Kitchen_Qual + Overall_Qual + Gr_Liv_Area,
  data = clean_ames_data
)

# 3.1 Coefficient summary
init_coefs <- tidy(lm_initial, conf.int = TRUE) %>%
  select(term, estimate, std.error, conf.low, conf.high, p.value) %>%
  mutate(across(where(is.numeric), ~ round(., 3)))
knitr::kable(init_coefs, caption = "Initial Model Coefficients")

# 3.2 Performance metrics
init_perf <- tibble::tibble(
  Metric = c("R-squared", "Adjusted R-squared"),
  Value  = c(summary(lm_initial)$r.squared, summary(lm_initial)$adj.r.squared)
) %>% mutate(Value = round(Value, 3))
knitr::kable(init_perf, caption = "Initial Model Performance Metrics")

# 3.3 Box-Cox lambda diagnostic
MASS::boxcox(lm_initial, main = "Box-Cox Plot (Initial Model)")

# 3.4 Scale-Location plot
plot(lm_initial, which = 3)

# 3.5 Residuals vs Observation Order + Durbin-Watson
resid_init <- residuals(lm_initial)
plot(seq_along(resid_init), resid_init, main = "Residuals vs. Index", xlab = "Index", ylab = "Residuals")
abline(h = 0, lty = 2)
print(car::durbinWatsonTest(lm_initial))

# 3.6 Influence measures: Cook's distance
cd <- cooks.distance(lm_initial)
high_inf <- which(cd > 4/(nrow(clean_ames_data) - length(coef(lm_initial)) - 1))
bad_pts <- tibble::tibble(
  Index = high_inf,
  CookD = round(cd[high_inf], 3)
)
knitr::kable(bad_pts, caption = "High Influence Observations (Initial Model)")

# Section 4: Outlier and Leverage Detection for Final Model
# Calculate counts for final_model (mlr_model_renovation)

# 1. Leverage values
hat_vals <- hatvalues(final_model)
lev_thresh <- 2 * length(coef(final_model)) / nrow(clean_ames_data)
num_high_lev <- sum(hat_vals > lev_thresh, na.rm = TRUE)
cat("Number of high leverage points:", num_high_lev, "
")

# 2. Standardized residuals
std_resid <- rstandard(final_model)
num_high_resid <- sum(abs(std_resid) > 2, na.rm = TRUE)
cat("Number of large standardized residuals (>|2|):", num_high_resid, "
")

# 3. Cook's distance
cookd <- cooks.distance(final_model)
cook_thresh <- 4 / (nrow(clean_ames_data) - length(coef(final_model)) - 1)
num_high_cook <- sum(cookd > cook_thresh, na.rm = TRUE)
cat("Number of high Cook's distance points:", num_high_cook, "
")

# 4. DFFITS
dffits_vals <- dffits(final_model)
dffits_thresh <- 2 * sqrt(length(coef(final_model)) / nrow(clean_ames_data))
num_high_dffits <- sum(abs(dffits_vals) > dffits_thresh, na.rm = TRUE)
cat("Number of high DFFITS points:", num_high_dffits, "
")

# 5. DFBETAs
dfbetas_vals <- dfbetas(final_model)
dfbetas_thresh <- 2 / sqrt(nrow(clean_ames_data))
high_dfbetas <- apply(abs(dfbetas_vals) > dfbetas_thresh, 1, function(x) any(x, na.rm = TRUE))
num_high_dfbetas <- sum(high_dfbetas, na.rm = TRUE)
cat("Number of points with any high DFBETAs:", num_high_dfbetas, "
")
```

# 14. VIF, Partial F-Test
```{r VIF, Partial F-Test, fig.height=4, fig.width=8, echo = FALSE}

vif_values_final <- vif(final_model)
print("VIF values for final model:")
print(vif_values_final)

vif_values_initial <- vif(lm_initial)
print("VIF values for initial model:")
print(vif_values_initial)

vif_df_initial <- data.frame(
  Variable = rownames(vif_values_initial),
  GVIF = vif_values_initial[,"GVIF"],
  Df = vif_values_initial[,"Df"],
  GVIF_adj = vif_values_initial[,"GVIF^(1/(2*Df))"]
)
knitr::kable(vif_df_initial, caption = "Variance Inflation Factors for Initial Model", digits = 3)

vif_df_final <- data.frame(
  Variable = rownames(vif_values_initial),
  GVIF = vif_values_final[,"GVIF"],
  Df = vif_values_final[,"Df"],
  GVIF_adj = vif_values_final[,"GVIF^(1/(2*Df))"]
)
knitr::kable(vif_df_final, caption = "Variance Inflation Factors for Final Model", digits = 3)


#Partial F-Test

partial_F_final <- Anova(final_model, type = 3)
partial_F_initial <- Anova(lm_initial, type = 3)

partial_F_final$Significant <- ifelse(partial_F_final$`Pr(>F)` < 0.05, "Yes", "No")
partial_F_initial$Significant <- ifelse(partial_F_initial$`Pr(>F)` < 0.05, "Yes", "No")

knitr::kable(partial_F_initial, caption="ANOVA Table of initial Model")
knitr::kable(partial_F_final, caption="ANOVA Table of final Model")

```
# 15. Summary Table
```{r Summary Table, fig.height=4, fig.width=8, echo = FALSE}

# Final Model Coefficient Summary with Confidence Intervals
final_coef_summary <- tidy(final_model, conf.int = TRUE) %>%
  select(term, estimate, std.error, conf.low, conf.high, p.value) %>%
  mutate(across(where(is.numeric), ~ round(., 4)))

# Create formatted table
final_coef_table <- final_coef_summary %>%
  mutate(
    CI = paste0("[", conf.low, ", ", conf.high, "]"),
    p.value = format.pval(p.value, digits = 3, eps = 0.001)
  ) %>%
  select(term, estimate, std.error, CI, p.value)

knitr::kable(final_coef_table, 
             caption = "Final Model Coefficients",
             col.names = c("Predictor", "Estimate", "Std. Error", 
                          "95% CI", "p-value"))

# Initial Model Performance Metrics
initial_metrics <- data.frame(
  Metric = c("R-squared", "Adjusted R-squared", "AIC", "BIC", "RMSE"),
  Value = c(
    round(summary(lm_initial)$r.squared, 4),
    round(summary(lm_initial)$adj.r.squared, 4),
    round(AIC(lm_initial), 2),
    round(BIC(lm_initial), 2),
    round(sqrt(mean(residuals(lm_initial)^2)), 4)
  )
)
knitr::kable(initial_metrics, caption = "Initial Model Performance")


# Final Model Performance Metrics
final_metrics <- data.frame(
  Metric = c("R-squared", "Adjusted R-squared", "AIC", "BIC", "RMSE"),
  Value = c(
    round(summary(final_model)$r.squared, 4),
    round(summary(final_model)$adj.r.squared, 4),
    round(AIC(final_model), 2),
    round(BIC(final_model), 2),
    round(sqrt(mean(residuals(final_model)^2)), 4)
  )
)
knitr::kable(final_metrics, caption = "Final Model Performance")




```


